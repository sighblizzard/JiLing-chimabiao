# ğŸ”§ å°ºç è¡¨ç”Ÿæˆå™¨ - æœ¬åœ°åç«¯å®ç°æŒ‡å—

## ğŸ“Š é¡¹ç›®çŠ¶å†µ

### å‰ç«¯ç°çŠ¶
- React 18 + Styled Components æ¶æ„å®Œå–„
- æ™ºèƒ½ç±»å‹è¯†åˆ«åŠŸèƒ½æ­£å¸¸ (100% æµ‹è¯•é€šè¿‡)
- å½“å‰ä½¿ç”¨ localStorage å­˜å‚¨æ•°æ®

### åç«¯ç›®æ ‡
- SQLite æœ¬åœ°æ•°æ®åº“æ›¿ä»£ localStorage
- Excel å¯¼å‡ºåŠŸèƒ½
- æ–‡ä»¶ç³»ç»Ÿé›†æˆ
- æ•°æ®å¤‡ä»½æ¢å¤

---

## ğŸš€ å®æ–½æ–¹æ¡ˆ

### æŠ€æœ¯æ¶æ„
```
React å‰ç«¯ â†” Electron IPC â†” SQLite æ•°æ®åº“
```

### æ ¸å¿ƒæŠ€æœ¯æ ˆ
- **æ•°æ®åº“**: SQLite3 + better-sqlite3
- **å¯¼å‡º**: ExcelJS
- **æ¡Œé¢**: Electron (å·²é…ç½®)
- **æ–‡ä»¶**: Node.js fs + path

---

## ğŸ“¦ ç¬¬ä¸€æ­¥ï¼šå®‰è£…ä¾èµ–

```bash
cd "d:\æ¡Œé¢\ç¼–ç¨‹\chi-ma-biao-7.16"

# å®‰è£…æ‰€æœ‰ä¾èµ–
npm install better-sqlite3 exceljs --save

# å¼€å‘ä¾èµ–ï¼ˆå¯é€‰ï¼‰
npm install @types/better-sqlite3 --save-dev
```

---

## ğŸ“ ç¬¬äºŒæ­¥ï¼šåˆ›å»ºæ•°æ®åº“æœåŠ¡

### 1. SQLite æ•°æ®åº“æœåŠ¡ (`src/services/localDatabase.js`)

```javascript
const Database = require('better-sqlite3');
const path = require('path');
const fs = require('fs');
const os = require('os');

class LocalDatabase {
  constructor() {
    this.appDir = path.join(os.homedir(), 'Documents', 'å°ºç è¡¨ç”Ÿæˆå™¨');
    this.dbPath = path.join(this.appDir, 'data.db');
    this.init();
  }
  
  init() {
    // ç¡®ä¿ç›®å½•å­˜åœ¨
    if (!fs.existsSync(this.appDir)) {
      fs.mkdirSync(this.appDir, { recursive: true });
    }
    
    // åˆå§‹åŒ–æ•°æ®åº“
    this.db = new Database(this.dbPath);
    this.db.pragma('journal_mode = WAL');
    this.createTables();
  }
  
  createTables() {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        type TEXT NOT NULL,
        base_value REAL NOT NULL,
        base_increment REAL NOT NULL,
        description TEXT DEFAULT '',
        is_custom INTEGER DEFAULT 1,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );
      
      CREATE TABLE IF NOT EXISTS size_charts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        mode TEXT DEFAULT 'normal',
        config TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );
      
      CREATE TABLE IF NOT EXISTS app_settings (
        key TEXT PRIMARY KEY,
        value TEXT NOT NULL,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );
    `);
  }
  
  // ç±»åˆ«æ“ä½œ
  createCategory(data) {
    const stmt = this.db.prepare(`
      INSERT INTO categories (name, type, base_value, base_increment, description, is_custom)
      VALUES (?, ?, ?, ?, ?, ?)
    `);
    return stmt.run(data.name, data.type, data.baseValue, data.baseIncrement, data.description || '', data.isCustom ? 1 : 0);
  }
  
  getCategories() {
    const categories = this.db.prepare('SELECT * FROM categories ORDER BY is_custom, created_at').all();
    // å°†æ•°æ®åº“å­—æ®µåè½¬æ¢ä¸ºé©¼å³°å‘½å
    return categories.map(cat => ({
      id: cat.id,
      name: cat.name,
      type: cat.type,
      baseValue: cat.base_value,
      baseIncrement: cat.base_increment,
      description: cat.description,
      isCustom: Boolean(cat.is_custom),
      createdAt: cat.created_at
    }));
  }
  
  updateCategory(id, updates) {
    // æ˜ å°„é©¼å³°å‘½ååˆ°æ•°æ®åº“å­—æ®µåï¼ŒåŒæ—¶è¿›è¡Œç™½åå•éªŒè¯
    const fieldMap = {
      name: 'name',
      type: 'type', 
      baseValue: 'base_value',
      baseIncrement: 'base_increment',
      description: 'description',
      isCustom: 'is_custom'
    };
    
    const dbUpdates = {};
    Object.keys(updates).forEach(key => {
      if (fieldMap[key]) {  // ç™½åå•éªŒè¯
        const dbKey = fieldMap[key];
        dbUpdates[dbKey] = updates[key];
      }
    });
    
    if (Object.keys(dbUpdates).length === 0) {
      throw new Error('æ²¡æœ‰æœ‰æ•ˆçš„æ›´æ–°å­—æ®µ');
    }
    
    const fields = Object.keys(dbUpdates).map(key => `${key} = ?`).join(', ');
    const values = [...Object.values(dbUpdates), id];
    return this.db.prepare(`UPDATE categories SET ${fields}, updated_at = CURRENT_TIMESTAMP WHERE id = ?`).run(...values);
  }
  
  deleteCategory(id) {
    return this.db.prepare('DELETE FROM categories WHERE id = ?').run(id);
  }
  
  // å°ºç è¡¨æ“ä½œ
  createSizeChart(data) {
    const stmt = this.db.prepare(`
      INSERT INTO size_charts (name, mode, config)
      VALUES (?, ?, ?)
    `);
    return stmt.run(data.name, data.mode || 'normal', JSON.stringify(data.config));
  }
  
  getSizeCharts() {
    const charts = this.db.prepare('SELECT * FROM size_charts ORDER BY created_at DESC').all();
    return charts.map(chart => {
      let config;
      try {
        config = JSON.parse(chart.config);
      } catch (error) {
        console.error('è§£æå°ºç è¡¨é…ç½®å¤±è´¥:', error);
        config = {};
      }
      return {
        id: chart.id,
        name: chart.name,
        mode: chart.mode,
        config: config,
        createdAt: chart.created_at
      };
    });
  }
  
  updateSizeChart(id, updates) {
    const fields = [];
    const values = [];
    
    // ç™½åå•éªŒè¯æ›´æ–°å­—æ®µ
    const allowedFields = ['name', 'mode', 'config'];
    
    if (updates.name && allowedFields.includes('name')) {
      fields.push('name = ?');
      values.push(updates.name);
    }
    if (updates.mode && allowedFields.includes('mode')) {
      fields.push('mode = ?');
      values.push(updates.mode);
    }
    if (updates.config && allowedFields.includes('config')) {
      fields.push('config = ?');
      values.push(JSON.stringify(updates.config));
    }
    
    if (fields.length === 0) {
      throw new Error('æ²¡æœ‰æœ‰æ•ˆçš„æ›´æ–°å­—æ®µ');
    }
    
    values.push(id);
    return this.db.prepare(`UPDATE size_charts SET ${fields.join(', ')} WHERE id = ?`).run(...values);
  }
  
  deleteSizeChart(id) {
    return this.db.prepare('DELETE FROM size_charts WHERE id = ?').run(id);
  }
  
  // è®¾ç½®æ“ä½œ
  setSetting(key, value) {
    return this.db.prepare(`
      INSERT OR REPLACE INTO app_settings (key, value, updated_at)
      VALUES (?, ?, CURRENT_TIMESTAMP)
    `).run(key, JSON.stringify(value));
  }
  
  getSetting(key, defaultValue = null) {
    const result = this.db.prepare('SELECT value FROM app_settings WHERE key = ?').get(key);
    if (result) {
      try {
        return JSON.parse(result.value);
      } catch (error) {
        console.error('è§£æè®¾ç½®å€¼å¤±è´¥:', error);
        return defaultValue;
      }
    }
    return defaultValue;
  }
  
  close() {
    if (this.db) this.db.close();
  }
}

module.exports = LocalDatabase;
```

### 2. æ•°æ®è¿ç§»å·¥å…· (`src/services/dataMigration.js`)

```javascript
class DataMigration {
  constructor(database) {
    this.db = database;
  }
  
  // ä»å‰ç«¯ä¼ é€’çš„ localStorage æ•°æ®è¿›è¡Œè¿ç§»
  migrateFromLocalStorage(localStorageData) {
    try {
      // è¿ç§»è‡ªå®šä¹‰ç±»åˆ«
      const customCategories = localStorageData.customCategories || [];
      customCategories.forEach(category => {
        // éªŒè¯å¿…éœ€å­—æ®µ
        if (!category.name || !category.type || category.baseValue === undefined || category.baseIncrement === undefined) {
          console.warn('è·³è¿‡æ— æ•ˆç±»åˆ«æ•°æ®:', category);
          return;
        }
        
        this.db.createCategory({
          name: category.name,
          type: category.type,
          baseValue: parseFloat(category.baseValue) || 0,
          baseIncrement: parseFloat(category.baseIncrement) || 0,
          description: category.description || '',
          isCustom: true
        });
      });
      
      // è¿ç§»å°ºç è¡¨
      const sizeCharts = localStorageData.sizeCharts || [];
      sizeCharts.forEach(chart => {
        this.db.createSizeChart({
          name: chart.name || 'æœªå‘½åå°ºç è¡¨',
          mode: chart.mode || 'normal',
          config: chart.config || chart
        });
      });
      
      // è¿ç§»è®¾ç½®
      const settingsKeys = ['sizeSettings', 'categoryStartValues', 'mode'];
      settingsKeys.forEach(key => {
        if (localStorageData[key]) {
          this.db.setSetting(key, localStorageData[key]);
        }
      });
      
      return { success: true, message: 'æ•°æ®è¿ç§»å®Œæˆ' };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
  
  // æ£€æŸ¥æ˜¯å¦éœ€è¦è¿ç§»ï¼ˆç”±å‰ç«¯è°ƒç”¨ï¼‰
  checkMigrationStatus() {
    try {
      // æ£€æŸ¥æ•°æ®åº“æ˜¯å¦ä¸ºç©ºï¼ˆéœ€è¦è¿ç§»ï¼‰
      const existingCategories = this.db.getCategories().filter(cat => cat.isCustom);
      const existingCharts = this.db.getSizeCharts();
      
      // å¦‚æœæ•°æ®åº“ä¸­æ²¡æœ‰è‡ªå®šä¹‰ç±»åˆ«å’Œå°ºç è¡¨ï¼Œåˆ™éœ€è¦è¿ç§»
      return existingCategories.length === 0 && existingCharts.length === 0;
    } catch (error) {
      console.error('æ£€æŸ¥è¿ç§»çŠ¶æ€å¤±è´¥:', error);
      return false;
    }
  }
}

module.exports = DataMigration;
```

---

## ğŸ”§ ç¬¬ä¸‰æ­¥ï¼šæ›´æ–° Electron ä¸»è¿›ç¨‹

### æ›´æ–° `electron/main.js` (æˆ– `src/main.js`)

```javascript
const { app, BrowserWindow, ipcMain, dialog } = require('electron');
const path = require('path');
const LocalDatabase = require('../src/services/localDatabase');
const DataMigration = require('../src/services/dataMigration');
const ExcelExporter = require('../src/services/excelExporter');

let mainWindow, database, migration, excelExporter;

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    }
  });

  const isDev = process.env.NODE_ENV === 'development';
  mainWindow.loadURL(isDev ? 'http://localhost:5173' : `file://${path.join(__dirname, '../dist/index.html')}`);
  if (isDev) mainWindow.webContents.openDevTools();
}

app.whenReady().then(() => {
  database = new LocalDatabase();
  migration = new DataMigration(database);
  excelExporter = new ExcelExporter();
  createWindow();
});

app.on('window-all-closed', () => {
  if (database) database.close();
  if (process.platform !== 'darwin') app.quit();
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// IPC å¤„ç†
const wrapHandler = (fn) => async (event, ...args) => {
  try {
    const result = await fn(...args);
    return { success: true, data: result };
  } catch (error) {
    return { success: false, error: error.message };
  }
};

ipcMain.handle('db-create-category', wrapHandler((data) => database.createCategory(data)));
ipcMain.handle('db-get-categories', wrapHandler(() => database.getCategories()));
ipcMain.handle('db-update-category', wrapHandler((id, updates) => database.updateCategory(id, updates)));
ipcMain.handle('db-delete-category', wrapHandler((id) => database.deleteCategory(id)));

ipcMain.handle('db-create-size-chart', wrapHandler((data) => database.createSizeChart(data)));
ipcMain.handle('db-get-size-charts', wrapHandler(() => database.getSizeCharts()));
ipcMain.handle('db-update-size-chart', wrapHandler((id, updates) => database.updateSizeChart(id, updates)));
ipcMain.handle('db-delete-size-chart', wrapHandler((id) => database.deleteSizeChart(id)));

ipcMain.handle('db-set-setting', wrapHandler((key, value) => database.setSetting(key, value)));
ipcMain.handle('db-get-setting', wrapHandler((key, defaultValue) => database.getSetting(key, defaultValue)));
ipcMain.handle('migrate-data', wrapHandler((localStorageData) => migration.migrateFromLocalStorage(localStorageData)));
ipcMain.handle('check-migration-status', wrapHandler(() => migration.checkMigrationStatus()));
```

### åˆ›å»º `electron/preload.js`

```javascript
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electronAPI', {
  // æ•°æ®åº“æ“ä½œ - ç±»åˆ«
  dbCreateCategory: (data) => ipcRenderer.invoke('db-create-category', data),
  dbGetCategories: () => ipcRenderer.invoke('db-get-categories'),
  dbUpdateCategory: (id, updates) => ipcRenderer.invoke('db-update-category', id, updates),
  dbDeleteCategory: (id) => ipcRenderer.invoke('db-delete-category', id),
  
  // æ•°æ®åº“æ“ä½œ - å°ºç è¡¨
  dbCreateSizeChart: (data) => ipcRenderer.invoke('db-create-size-chart', data),
  dbGetSizeCharts: () => ipcRenderer.invoke('db-get-size-charts'),
  dbUpdateSizeChart: (id, updates) => ipcRenderer.invoke('db-update-size-chart', id, updates),
  dbDeleteSizeChart: (id) => ipcRenderer.invoke('db-delete-size-chart', id),
  
  // è®¾ç½®æ“ä½œ
  dbSetSetting: (key, value) => ipcRenderer.invoke('db-set-setting', key, value),
  dbGetSetting: (key, defaultValue) => ipcRenderer.invoke('db-get-setting', key, defaultValue),
  
  // æ•°æ®è¿ç§»
  migrateData: (localStorageData) => ipcRenderer.invoke('migrate-data', localStorageData),
  checkMigrationStatus: () => ipcRenderer.invoke('check-migration-status'),
  
  // æ–‡ä»¶æ“ä½œ
  showSaveDialog: (options) => ipcRenderer.invoke('show-save-dialog', options),
  exportExcel: (data) => ipcRenderer.invoke('export-excel', data)
});
```

---

## ğŸ”„ ç¬¬å››æ­¥ï¼šæ›´æ–°å‰ç«¯æ•°æ®è®¿é—®

### æ›´æ–° `src/services/dataManager.js`

```javascript
// æ£€æŸ¥æ˜¯å¦åœ¨ Electron ç¯å¢ƒ
const isElectron = window.electronAPI;

// åŸæœ‰æ¥å£ä¿æŒä¸å˜ï¼Œå†…éƒ¨å®ç°åˆ‡æ¢
export const createCategory = async (categoryData) => {
  if (isElectron) {
    const result = await window.electronAPI.dbCreateCategory(categoryData);
    if (!result.success) throw new Error(result.error);
    return result.data;
  } else {
    // é™çº§åˆ° localStorage (å¼€å‘ç¯å¢ƒ)
    return createCategoryLocal(categoryData);
  }
};

export const getCategories = async () => {
  if (isElectron) {
    const result = await window.electronAPI.dbGetCategories();
    return result.success ? result.data : [];
  } else {
    return getCategoriesLocal();
  }
};

export const updateCategory = async (id, updates) => {
  if (isElectron) {
    const result = await window.electronAPI.dbUpdateCategory(id, updates);
    if (!result.success) throw new Error(result.error);
    return result.data;
  } else {
    // é™çº§åˆ° localStorage (å¼€å‘ç¯å¢ƒ)
    return updateCategoryLocal(id, updates);
  }
};

export const deleteCategory = async (id) => {
  if (isElectron) {
    const result = await window.electronAPI.dbDeleteCategory(id);
    if (!result.success) throw new Error(result.error);
    return result.data;
  } else {
    // é™çº§åˆ° localStorage (å¼€å‘ç¯å¢ƒ)
    return deleteCategoryLocal(id);
  }
};

// å°ºç è¡¨æ“ä½œ
export const createSizeChart = async (chartData) => {
  if (isElectron) {
    const result = await window.electronAPI.dbCreateSizeChart(chartData);
    if (!result.success) throw new Error(result.error);
    return result.data;
  } else {
    // é™çº§åˆ° localStorage (å¼€å‘ç¯å¢ƒ)
    return createSizeChartLocal(chartData);
  }
};

export const getSizeCharts = async () => {
  if (isElectron) {
    const result = await window.electronAPI.dbGetSizeCharts();
    return result.success ? result.data : [];
  } else {
    return getSizeChartsLocal();
  }
};

export const updateSizeChart = async (id, updates) => {
  if (isElectron) {
    const result = await window.electronAPI.dbUpdateSizeChart(id, updates);
    if (!result.success) throw new Error(result.error);
    return result.data;
  } else {
    // é™çº§åˆ° localStorage (å¼€å‘ç¯å¢ƒ)
    return updateSizeChartLocal(id, updates);
  }
};

export const deleteSizeChart = async (id) => {
  if (isElectron) {
    const result = await window.electronAPI.dbDeleteSizeChart(id);
    if (!result.success) throw new Error(result.error);
    return result.data;
  } else {
    // é™çº§åˆ° localStorage (å¼€å‘ç¯å¢ƒ)
    return deleteSizeChartLocal(id);
  }
};

// localStorage é™çº§å‡½æ•° (ä¿ç•™ç°æœ‰é€»è¾‘ä½œä¸ºå¤‡ç”¨)
const createCategoryLocal = (categoryData) => {
  try {
    const categories = JSON.parse(localStorage.getItem('customCategories') || '[]');
    const newCategory = { ...categoryData, id: Date.now(), createdAt: new Date().toISOString() };
    categories.push(newCategory);
    localStorage.setItem('customCategories', JSON.stringify(categories));
    return newCategory;
  } catch (error) {
    console.error('localStorage æ“ä½œå¤±è´¥:', error);
    throw error;
  }
};

const getCategoriesLocal = () => {
  try {
    return JSON.parse(localStorage.getItem('customCategories') || '[]');
  } catch (error) {
    console.error('è¯»å– localStorage å¤±è´¥:', error);
    return [];
  }
};

const updateCategoryLocal = (id, updates) => {
  try {
    const categories = JSON.parse(localStorage.getItem('customCategories') || '[]');
    const index = categories.findIndex(cat => cat.id === id);
    if (index !== -1) {
      categories[index] = { ...categories[index], ...updates, updatedAt: new Date().toISOString() };
      localStorage.setItem('customCategories', JSON.stringify(categories));
      return categories[index];
    }
    throw new Error('ç±»åˆ«ä¸å­˜åœ¨');
  } catch (error) {
    console.error('æ›´æ–° localStorage å¤±è´¥:', error);
    throw error;
  }
};

const deleteCategoryLocal = (id) => {
  try {
    const categories = JSON.parse(localStorage.getItem('customCategories') || '[]');
    const filteredCategories = categories.filter(cat => cat.id !== id);
    localStorage.setItem('customCategories', JSON.stringify(filteredCategories));
    return { success: true };
  } catch (error) {
    console.error('åˆ é™¤ localStorage å¤±è´¥:', error);
    throw error;
  }
};

// å°ºç è¡¨ localStorage é™çº§å‡½æ•°
const createSizeChartLocal = (chartData) => {
  try {
    const charts = JSON.parse(localStorage.getItem('sizeCharts') || '[]');
    const newChart = { ...chartData, id: Date.now(), createdAt: new Date().toISOString() };
    charts.push(newChart);
    localStorage.setItem('sizeCharts', JSON.stringify(charts));
    return newChart;
  } catch (error) {
    console.error('localStorage æ“ä½œå¤±è´¥:', error);
    throw error;
  }
};

const getSizeChartsLocal = () => {
  try {
    return JSON.parse(localStorage.getItem('sizeCharts') || '[]');
  } catch (error) {
    console.error('è¯»å– localStorage å¤±è´¥:', error);
    return [];
  }
};

const updateSizeChartLocal = (id, updates) => {
  try {
    const charts = JSON.parse(localStorage.getItem('sizeCharts') || '[]');
    const index = charts.findIndex(chart => chart.id === id);
    if (index !== -1) {
      charts[index] = { ...charts[index], ...updates, updatedAt: new Date().toISOString() };
      localStorage.setItem('sizeCharts', JSON.stringify(charts));
      return charts[index];
    }
    throw new Error('å°ºç è¡¨ä¸å­˜åœ¨');
  } catch (error) {
    console.error('æ›´æ–° localStorage å¤±è´¥:', error);
    throw error;
  }
};

const deleteSizeChartLocal = (id) => {
  try {
    const charts = JSON.parse(localStorage.getItem('sizeCharts') || '[]');
    const filteredCharts = charts.filter(chart => chart.id !== id);
    localStorage.setItem('sizeCharts', JSON.stringify(filteredCharts));
    return { success: true };
  } catch (error) {
    console.error('åˆ é™¤ localStorage å¤±è´¥:', error);
    throw error;
  }
};

// æ•°æ®è¿ç§»æ£€æŸ¥
export const checkAndMigrate = async () => {
  if (isElectron) {
    try {
      // æ£€æŸ¥æ˜¯å¦æœ‰æœ¬åœ°æ•°æ®éœ€è¦è¿ç§»
      const hasLocalData = localStorage.getItem('customCategories') || 
                          localStorage.getItem('sizeSettings') ||
                          localStorage.getItem('categoryStartValues') ||
                          localStorage.getItem('mode');
      
      if (!hasLocalData) return false;
      
      // æ£€æŸ¥æ•°æ®åº“æ˜¯å¦éœ€è¦è¿ç§»
      const statusResult = await window.electronAPI.checkMigrationStatus();
      if (!statusResult.success || !statusResult.data) return false;
      
      // æ”¶é›† localStorage æ•°æ®
      const localStorageData = {};
      
      try {
        localStorageData.customCategories = JSON.parse(localStorage.getItem('customCategories') || '[]');
      } catch {
        localStorageData.customCategories = [];
      }
      
      try {
        localStorageData.sizeCharts = JSON.parse(localStorage.getItem('sizeCharts') || '[]');
      } catch {
        localStorageData.sizeCharts = [];
      }
      
      try {
        localStorageData.sizeSettings = JSON.parse(localStorage.getItem('sizeSettings') || '{}');
      } catch {
        localStorageData.sizeSettings = {};
      }
      
      try {
        localStorageData.categoryStartValues = JSON.parse(localStorage.getItem('categoryStartValues') || '{}');
      } catch {
        localStorageData.categoryStartValues = {};
      }
      
      localStorageData.mode = localStorage.getItem('mode') || 'normal';
      
      // æ‰§è¡Œè¿ç§»
      const result = await window.electronAPI.migrateData(localStorageData);
      if (result.success) {
        // æ¸…ç† localStorage
        ['customCategories', 'sizeCharts', 'sizeSettings', 'categoryStartValues', 'mode'].forEach(key => {
          localStorage.removeItem(key);
        });
        console.log('æ•°æ®è¿ç§»å®Œæˆ');
        return true;
      }
    } catch (error) {
      console.error('æ•°æ®è¿ç§»å¤±è´¥:', error);
    }
  }
  return false;
};
```

---

## ğŸ“„ ç¬¬äº”æ­¥ï¼šå¯¼å‡ºåŠŸèƒ½å®ç°

### Excel å¯¼å‡ºæœåŠ¡ (`src/services/excelExporter.js`)

```javascript
const ExcelJS = require('exceljs');

class ExcelExporter {
  async exportSizeChart(chartData, filePath) {
    if (!chartData || chartData.length === 0) {
      throw new Error('æ²¡æœ‰æ•°æ®å¯å¯¼å‡º');
    }
    
    const workbook = new ExcelJS.Workbook();
    workbook.creator = 'å°ºç è¡¨ç”Ÿæˆå™¨';
    workbook.created = new Date();
    
    const worksheet = workbook.addWorksheet('å°ºç è¡¨');
    
    // è®¾ç½®è¡¨å¤´æ ·å¼
    const headers = Object.keys(chartData[0]);
    const headerRow = worksheet.getRow(1);
    headers.forEach((header, index) => {
      const cell = headerRow.getCell(index + 1);
      cell.value = header;
      cell.font = { color: { argb: 'FFFFFFFF' }, bold: true };
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF366092' } };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
    });
    
    // æ·»åŠ æ•°æ®
    chartData.forEach((row, rowIndex) => {
      const dataRow = worksheet.getRow(rowIndex + 2);
      headers.forEach((header, colIndex) => {
        dataRow.getCell(colIndex + 1).value = row[header];
      });
    });
    
    // è‡ªåŠ¨è°ƒæ•´åˆ—å®½
    worksheet.columns.forEach(column => {
      column.width = 15;
    });
    
    // æ·»åŠ è¾¹æ¡†
    const borderStyle = { style: 'thin' };
    for (let row = 1; row <= chartData.length + 1; row++) {
      for (let col = 1; col <= headers.length; col++) {
        worksheet.getCell(row, col).border = {
          top: borderStyle,
          left: borderStyle,
          bottom: borderStyle,
          right: borderStyle
        };
      }
    }
    
    await workbook.xlsx.writeFile(filePath);
    return { success: true, filePath };
  }
}

module.exports = ExcelExporter;
```

### åœ¨ main.js ä¸­æ·»åŠ å¯¼å‡ºå¤„ç†

// æ·»åŠ æ–‡ä»¶å¯¹è¯æ¡†å¤„ç†
ipcMain.handle('show-save-dialog', async (event, options) => {
  try {
    const result = await dialog.showSaveDialog(mainWindow, {
      filters: [{ name: 'Excel Files', extensions: ['xlsx'] }],
      defaultPath: `å°ºç è¡¨_${new Date().toISOString().split('T')[0]}.xlsx`,
      ...options
    });
    return { success: true, data: result };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// å¯¼å‡º Excel å¤„ç†
ipcMain.handle('export-excel', async (event, data) => {
  try {
    // éªŒè¯æ•°æ®æ ¼å¼
    if (!data || !data.chartData || !Array.isArray(data.chartData) || data.chartData.length === 0) {
      return { success: false, error: 'æ— æ•ˆçš„å¯¼å‡ºæ•°æ®' };
    }
    
    // å…ˆæ˜¾ç¤ºä¿å­˜å¯¹è¯æ¡†
    const dialogResult = await dialog.showSaveDialog(mainWindow, {
      filters: [{ name: 'Excel Files', extensions: ['xlsx'] }],
      defaultPath: `å°ºç è¡¨_${new Date().toISOString().split('T')[0]}.xlsx`
    });
    
    if (dialogResult.canceled) {
      return { success: false, message: 'ç”¨æˆ·å–æ¶ˆä¿å­˜' };
    }
    
    // æ‰§è¡Œå¯¼å‡º
    const result = await excelExporter.exportSizeChart(data.chartData, dialogResult.filePath);
    return { success: true, data: result };
  } catch (error) {
    return { success: false, error: error.message };
  }
});
```javascript
const LocalDatabase = require('../src/services/localDatabase');

async function testDatabase() {
  console.log('ğŸ§ª æµ‹è¯• SQLite æ•°æ®åº“...\n');
  
  const db = new LocalDatabase();
  
  try {
    // æµ‹è¯•åˆ›å»ºç±»åˆ«
    const result = db.createCategory({
      name: 'æµ‹è¯•èƒ¸å›´',
      type: 'chest',
      baseValue: 88,
      baseIncrement: 4,
      description: 'æµ‹è¯•ç±»åˆ«',
      isCustom: true
    });
    console.log('âœ… åˆ›å»ºç±»åˆ«æˆåŠŸ, ID:', result.lastInsertRowid);
    
    // æµ‹è¯•è·å–ç±»åˆ«
    const categories = db.getCategories();
    console.log('âœ… è·å–ç±»åˆ«:', categories.length, 'ä¸ª');
    console.log('   ç¤ºä¾‹æ•°æ®:', categories[0]);
    
    // æµ‹è¯•æ›´æ–°ç±»åˆ«
    if (categories.length > 0) {
      const updateResult = db.updateCategory(categories[0].id, { 
        baseValue: 90,
        description: 'æ›´æ–°çš„æµ‹è¯•ç±»åˆ«' 
      });
      console.log('âœ… æ›´æ–°ç±»åˆ«æˆåŠŸ');
    }
    
    // æµ‹è¯•è®¾ç½®
    db.setSetting('testSetting', { mode: 'normal', count: 4 });
    const setting = db.getSetting('testSetting');
    console.log('âœ… è®¾ç½®æµ‹è¯•:', setting);
    
    console.log('\nğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼');
  } catch (error) {
    console.error('âŒ æµ‹è¯•å¤±è´¥:', error);
  } finally {
    db.close();
  }
}

// ç«‹å³æ‰§è¡Œæµ‹è¯•
testDatabase();
```

---

## ğŸ“‹ æ‰§è¡Œæ¸…å•

### ç«‹å³æ‰§è¡Œ
1. **å®‰è£…ä¾èµ–**: `npm install better-sqlite3 exceljs --save`
2. **åˆ›å»ºæ–‡ä»¶**: æŒ‰ä¸Šè¿°ä»£ç åˆ›å»ºæ‰€æœ‰æœåŠ¡æ–‡ä»¶
3. **æµ‹è¯•æ•°æ®åº“**: `node test/test-sqlite.js`
4. **æ›´æ–°å‰ç«¯**: ä¿®æ”¹ dataManager.js æ”¯æŒæ•°æ®åº“è°ƒç”¨
5. **å¯åŠ¨åº”ç”¨**: `npm run electron` éªŒè¯åŠŸèƒ½

### éªŒæ”¶æ ‡å‡†
- SQLite æ•°æ®åº“æ–‡ä»¶åˆ›å»ºåœ¨ `~/Documents/å°ºç è¡¨ç”Ÿæˆå™¨/data.db`
- å‰ç«¯å¯ä»¥æ­£å¸¸åˆ›å»ºã€è¯»å–ã€æ›´æ–°ã€åˆ é™¤ç±»åˆ«
- localStorage æ•°æ®è‡ªåŠ¨è¿ç§»åˆ°æ•°æ®åº“
- Excel å¯¼å‡ºåŠŸèƒ½å¯ç”¨
- åº”ç”¨è¿è¡Œç¨³å®šï¼Œæ— æ•°æ®ä¸¢å¤±

### æ–‡ä»¶ç»“æ„
```text
src/
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ localDatabase.js     # SQLite æ•°æ®åº“æœåŠ¡
â”‚   â”œâ”€â”€ dataMigration.js     # æ•°æ®è¿ç§»å·¥å…·
â”‚   â”œâ”€â”€ excelExporter.js     # Excel å¯¼å‡ºæœåŠ¡
â”‚   â””â”€â”€ dataManager.js       # å‰ç«¯æ•°æ®è®¿é—®å±‚ (æ›´æ–°)
â”œâ”€â”€ electron/
â”‚   â”œâ”€â”€ main.js              # Electron ä¸»è¿›ç¨‹ (æ›´æ–°)
â”‚   â””â”€â”€ preload.js           # å®‰å…¨é€šä¿¡å±‚ (æ–°å»º)
â””â”€â”€ test/
    â””â”€â”€ test-sqlite.js       # æ•°æ®åº“æµ‹è¯• (æ–°å»º)
```

---

## ğŸ¯ æ ¸å¿ƒä¼˜åŠ¿

- **å¯é å­˜å‚¨**: SQLite æ›¿ä»£ localStorageï¼Œæ•°æ®æ°¸ä¸ä¸¢å¤±
- **ç¦»çº¿ä½¿ç”¨**: å®Œå…¨æœ¬åœ°åŒ–ï¼Œæ— éœ€ç½‘ç»œè¿æ¥
- **ä¸“ä¸šå¯¼å‡º**: Excel é«˜è´¨é‡æ–‡ä»¶è¾“å‡º
- **å‘åå…¼å®¹**: è‡ªåŠ¨è¿ç§»ç°æœ‰æ•°æ®ï¼Œç”¨æˆ·æ— æ„ŸçŸ¥
- **æ˜“äºç»´æŠ¤**: æŠ€æœ¯æ ˆç®€å•ï¼Œæ‰©å±•æ€§å¼º

å®Œæˆä»¥ä¸Šæ­¥éª¤åï¼Œä½ çš„å°ºç è¡¨ç”Ÿæˆå™¨å°†æ‹¥æœ‰ä¼ä¸šçº§çš„æ•°æ®å¯é æ€§å’Œä¸“ä¸šçš„å¯¼å‡ºåŠŸèƒ½ï¼
